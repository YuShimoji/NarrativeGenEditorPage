import React, { useState, useEffect } from 'react'
import { useWikiStore, WikiEntry, EntryCategory, EntryRelation, RelationType } from '../store/useWikiStore'

interface WikiEntryEditorProps {
  entry?: WikiEntry
  isOpen: boolean
  onClose: () => void
  onSave?: (entry: WikiEntry) => void
}

export const WikiEntryEditor: React.FC<WikiEntryEditorProps> = ({
  entry,
  isOpen,
  onClose,
  onSave
}) => {
  const { addEntry, updateEntry, entries } = useWikiStore()
  
  const [formData, setFormData] = useState({
    title: '',
    slug: '',
    content: {
      markdown: '',
      summary: ''
    },
    category: EntryCategory.CHARACTER as EntryCategory,
    tags: [] as string[],
    metadata: {
      readCount: 0,
      importance: 3,
      spoilerLevel: 1,
      firstMentionScene: undefined as string | undefined,
      lastUpdateScene: undefined as string | undefined,
      extractionSource: [] as string[]
    },
    relations: [] as EntryRelation[],
    autoGenerated: false
  })
  
  const [tagInput, setTagInput] = useState('')
  const [relationInput, setRelationInput] = useState({
    targetId: '',
    relationType: RelationType.RELATED_TO,
    strength: 1,
    description: '',
    bidirectional: false
  })

  // エントリが変更されたときにフォームデータを更新
  useEffect(() => {
    if (entry) {
      setFormData({
        title: entry.title,
        slug: entry.slug,
        content: entry.content,
        category: entry.category,
        tags: [...entry.tags],
        metadata: {
          ...entry.metadata,
          firstMentionScene: entry.metadata.firstMentionScene || undefined,
          lastUpdateScene: entry.metadata.lastUpdateScene || undefined
        },
        relations: [...entry.relations],
        autoGenerated: entry.autoGenerated
      })
    } else {
      // 新規エントリの場合はリセット
      setFormData({
        title: '',
        slug: '',
        content: {
          markdown: '',
          summary: ''
        },
        category: EntryCategory.CHARACTER,
        tags: [],
        metadata: {
          readCount: 0,
          importance: 3,
          spoilerLevel: 1,
          firstMentionScene: undefined as string | undefined,
          lastUpdateScene: undefined as string | undefined,
          extractionSource: []
        },
        relations: [],
        autoGenerated: false
      })
    }
  }, [entry, isOpen])

  const handleSave = () => {
    // スラッグの自動生成（タイトルが変更された場合）
    const slug = formData.slug || formData.title.toLowerCase()
      .replace(/[^a-z0-9\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')

    const entryData: WikiEntry = {
      ...formData,
      id: entry?.id || `entry-${Date.now()}`,
      slug,
      createdAt: entry?.createdAt || new Date(),
      updatedAt: new Date()
    }

    if (entry) {
      updateEntry(entry.id, entryData)
    } else {
      addEntry(entryData)
    }

    onSave?.(entryData)
    onClose()
  }

  const handleAddTag = () => {
    if (tagInput.trim() && !formData.tags.includes(tagInput.trim())) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, tagInput.trim()]
      }))
      setTagInput('')
    }
  }

  const handleRemoveTag = (tag: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(t => t !== tag)
    }))
  }

  const handleAddRelation = () => {
    if (relationInput.targetId && relationInput.targetId !== entry?.id) {
      const newRelation: EntryRelation = {
        targetId: relationInput.targetId,
        relationType: relationInput.relationType,
        strength: relationInput.strength,
        description: relationInput.description || undefined,
        bidirectional: relationInput.bidirectional
      }
      
      setFormData(prev => ({
        ...prev,
        relations: [...prev.relations, newRelation]
      }))
      
      setRelationInput({
        targetId: '',
        relationType: RelationType.RELATED_TO,
        strength: 1,
        description: '',
        bidirectional: false
      })
    }
  }

  const handleRemoveRelation = (index: number) => {
    setFormData(prev => ({
      ...prev,
      relations: prev.relations.filter((_, i) => i !== index)
    }))
  }

  const availableEntries = entries.filter(e => e.id !== entry?.id)

  if (!isOpen) return null

  return (
    <div className="wiki-entry-editor-overlay">
      <div className="wiki-entry-editor-modal">
        <div className="wiki-entry-editor-header">
          <h3>{entry ? 'エントリ編集' : '新規エントリ作成'}</h3>
          <button className="close-btn" onClick={onClose}>×</button>
        </div>

        <div className="wiki-entry-editor-content">
          {/* 基本情報 */}
          <div className="editor-section">
            <h4>基本情報</h4>
            
            <div className="form-group">
              <label>タイトル</label>
              <input
                type="text"
                value={formData.title}
                onChange={(e) => setFormData(prev => ({ ...prev, title: e.target.value }))}
                placeholder="エントリのタイトル"
              />
            </div>

            <div className="form-group">
              <label>スラッグ（URL用ID）</label>
              <input
                type="text"
                value={formData.slug}
                onChange={(e) => setFormData(prev => ({ ...prev, slug: e.target.value }))}
                placeholder="自動生成されます"
              />
            </div>

            <div className="form-group">
              <label>カテゴリ</label>
              <select
                value={formData.category}
                onChange={(e) => setFormData(prev => ({ ...prev, category: e.target.value as EntryCategory }))}
              >
                <option value={EntryCategory.CHARACTER}>👤 キャラクター</option>
                <option value={EntryCategory.LOCATION}>🏛️ 場所</option>
                <option value={EntryCategory.ITEM}>💎 アイテム</option>
                <option value={EntryCategory.ORGANIZATION}>🏢 組織</option>
                <option value={EntryCategory.EVENT}>⚡ イベント</option>
                <option value={EntryCategory.CONCEPT}>💭 概念</option>
                <option value={EntryCategory.LORE}>📚 設定・伝承</option>
              </select>
            </div>
          </div>

          {/* コンテンツ */}
          <div className="editor-section">
            <h4>コンテンツ</h4>
            
            <div className="form-group">
              <label>概要</label>
              <input
                type="text"
                value={formData.content.summary}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  content: { ...prev.content, summary: e.target.value }
                }))}
                placeholder="エントリの簡潔な説明"
              />
            </div>

            <div className="form-group">
              <label>詳細（Markdown）</label>
              <textarea
                value={formData.content.markdown}
                onChange={(e) => setFormData(prev => ({
                  ...prev,
                  content: { ...prev.content, markdown: e.target.value }
                }))}
                placeholder="詳細な説明をMarkdown形式で記述"
                rows={8}
              />
            </div>
          </div>

          {/* タグ */}
          <div className="editor-section">
            <h4>タグ</h4>
            
            <div className="tag-input-group">
              <input
                type="text"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                placeholder="タグを追加"
                onKeyPress={(e) => e.key === 'Enter' && handleAddTag()}
              />
              <button onClick={handleAddTag}>追加</button>
            </div>
            
            <div className="tag-list">
              {formData.tags.map(tag => (
                <span key={tag} className="tag-item">
                  #{tag}
                  <button onClick={() => handleRemoveTag(tag)}>×</button>
                </span>
              ))}
            </div>
          </div>

          {/* メタデータ */}
          <div className="editor-section">
            <h4>メタデータ</h4>
            
            <div className="form-row">
              <div className="form-group">
                <label>重要度 (1-5)</label>
                <input
                  type="number"
                  min="1"
                  max="5"
                  value={formData.metadata.importance}
                  onChange={(e) => setFormData(prev => ({
                    ...prev,
                    metadata: { ...prev.metadata, importance: parseInt(e.target.value) }
                  }))}
                />
              </div>
              
              <div className="form-group">
                <label>ネタバレレベル (1-5)</label>
                <input
                  type="number"
                  min="1"
                  max="5"
                  value={formData.metadata.spoilerLevel}
                  onChange={(e) => setFormData(prev => ({
                    ...prev,
                    metadata: { ...prev.metadata, spoilerLevel: parseInt(e.target.value) }
                  }))}
                />
              </div>
            </div>
          </div>

          {/* 関連項目 */}
          <div className="editor-section">
            <h4>関連項目</h4>
            
            <div className="relation-input-group">
              <select
                value={relationInput.targetId}
                onChange={(e) => setRelationInput(prev => ({ ...prev, targetId: e.target.value }))}
              >
                <option value="">関連エントリを選択</option>
                {availableEntries.map(entry => (
                  <option key={entry.id} value={entry.id}>{entry.title}</option>
                ))}
              </select>
              
              <select
                value={relationInput.relationType}
                onChange={(e) => setRelationInput(prev => ({ ...prev, relationType: e.target.value as RelationType }))}
              >
                <option value={RelationType.RELATED_TO}>関連</option>
                <option value={RelationType.APPEARS_WITH}>共演</option>
                <option value={RelationType.LOCATED_IN}>所在</option>
                <option value={RelationType.BELONGS_TO}>所属</option>
                <option value={RelationType.CAUSED_BY}>原因</option>
                <option value={RelationType.PART_OF}>一部</option>
              </select>
              
              <input
                type="number"
                min="1"
                max="5"
                value={relationInput.strength}
                onChange={(e) => setRelationInput(prev => ({ ...prev, strength: parseInt(e.target.value) }))}
                placeholder="強度"
                style={{ width: '60px' }}
              />
              
              <input
                type="text"
                value={relationInput.description}
                onChange={(e) => setRelationInput(prev => ({ ...prev, description: e.target.value }))}
                placeholder="関係の説明（任意）"
              />
              
              <button onClick={handleAddRelation}>追加</button>
            </div>
            
            <div className="relation-list">
              {formData.relations.map((relation, index) => {
                const targetEntry = entries.find(e => e.id === relation.targetId)
                return (
                  <div key={index} className="relation-item">
                    <span className="relation-type">{relation.relationType}</span>
                    <span className="relation-target">{targetEntry?.title || '不明'}</span>
                    <span className="relation-strength">強度: {relation.strength}</span>
                    {relation.description && (
                      <span className="relation-desc">({relation.description})</span>
                    )}
                    <button onClick={() => handleRemoveRelation(index)}>×</button>
                  </div>
                )
              })}
            </div>
          </div>
        </div>

        <div className="wiki-entry-editor-footer">
          <button className="cancel-btn" onClick={onClose}>キャンセル</button>
          <button className="save-btn" onClick={handleSave}>保存</button>
        </div>
      </div>
    </div>
  )
}
