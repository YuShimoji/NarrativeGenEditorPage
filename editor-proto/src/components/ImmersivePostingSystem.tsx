import React, { useState } from 'react'
import { useWikiStore, EntryCategory } from '../store/useWikiStore'
import { useSceneStore } from '../store/useSceneStore'

interface ImmersivePost {
  id: string
  type: 'character_writing' | 'rumor' | 'quote' | 'diary' | 'letter' | 'news'
  title: string
  content: string
  author: string
  authorType: 'character' | 'organization' | 'anonymous'
  timestamp: string
  sceneId?: string
  tags: string[]
  metadata: {
    reliability: number // 0-100 (å™‚ã®ä¿¡æ†‘æ€§ãªã©)
    importance: number // 0-100
    spoilerLevel: number // 0-5
    targetAudience: string[] // ['public', 'nobles', 'scholars', etc.]
  }
}

interface ImmersivePostingSystemProps {
  isOpen: boolean
  onClose: () => void
}

export const ImmersivePostingSystem: React.FC<ImmersivePostingSystemProps> = ({
  isOpen,
  onClose
}) => {
  const { entries } = useWikiStore()
  const { getCurrentScene } = useSceneStore()
  
  const [postType, setPostType] = useState<ImmersivePost['type']>('character_writing')
  const [title, setTitle] = useState('')
  const [content, setContent] = useState('')
  const [author, setAuthor] = useState('')
  const [authorType, setAuthorType] = useState<'character' | 'organization' | 'anonymous'>('character')
  const [tags, setTags] = useState<string[]>([])
  const [reliability, setReliability] = useState(80)
  const [importance, setImportance] = useState(50)
  const [spoilerLevel, setSpoilerLevel] = useState(0)
  const [targetAudience, setTargetAudience] = useState<string[]>(['public'])

  const postTypeTemplates = {
    character_writing: {
      title: 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼åŸ·ç­†',
      placeholder: 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æ‰‹è¨˜ã€æ—¥è¨˜ã€å›æƒ³éŒ²ãªã©...',
      icon: 'âœï¸',
      defaultTags: ['character', 'writing', 'personal']
    },
    rumor: {
      title: 'å™‚ãƒ»é¢¨è',
      placeholder: 'è¡—ã§å›ã‹ã‚Œã‚‹å™‚ã€æœªç¢ºèªæƒ…å ±ãªã©...',
      icon: 'ğŸ‘‚',
      defaultTags: ['rumor', 'gossip', 'unconfirmed']
    },
    quote: {
      title: 'åè¨€ãƒ»æ ¼è¨€',
      placeholder: 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å°è±¡çš„ãªç™ºè¨€ã€æ ¼è¨€ãªã©...',
      icon: 'ğŸ’¬',
      defaultTags: ['quote', 'wisdom', 'memorable']
    },
    diary: {
      title: 'æ—¥è¨˜ãƒ»è¨˜éŒ²',
      placeholder: 'æ—¥ã€…ã®å‡ºæ¥äº‹ã€è¦³å¯Ÿè¨˜éŒ²ãªã©...',
      icon: 'ğŸ“”',
      defaultTags: ['diary', 'record', 'daily']
    },
    letter: {
      title: 'æ‰‹ç´™ãƒ»æ–‡æ›¸',
      placeholder: 'æ‰‹ç´™ã€å…¬æ–‡æ›¸ã€å¥‘ç´„æ›¸ãªã©...',
      icon: 'ğŸ“œ',
      defaultTags: ['letter', 'document', 'correspondence']
    },
    news: {
      title: 'ãƒ‹ãƒ¥ãƒ¼ã‚¹ãƒ»å‘ŠçŸ¥',
      placeholder: 'å…¬å¼ç™ºè¡¨ã€ãƒ‹ãƒ¥ãƒ¼ã‚¹ã€å‘ŠçŸ¥ãªã©...',
      icon: 'ğŸ“°',
      defaultTags: ['news', 'announcement', 'official']
    }
  }

  const characterEntries = entries.filter(entry => entry.category === EntryCategory.CHARACTER)
  const organizationEntries = entries.filter(entry => entry.category === EntryCategory.ORGANIZATION)

  const handleSubmit = () => {
    const currentScene = getCurrentScene()
    
    const newPost: ImmersivePost = {
      id: `post-${Date.now()}`,
      type: postType,
      title,
      content,
      author,
      authorType,
      timestamp: new Date().toISOString(),
      sceneId: currentScene?.id,
      tags: [...tags, ...postTypeTemplates[postType].defaultTags],
      metadata: {
        reliability,
        importance,
        spoilerLevel,
        targetAudience
      }
    }

    // Wikiã‚¨ãƒ³ãƒˆãƒªã¨ã—ã¦Immersive Postã‚’ä¿å­˜
    const wikiEntry = {
      title: `${postTypeTemplates[postType].icon} ${title}`,
      slug: `immersive-${newPost.id}`,
      content: {
        markdown: formatPostAsMarkdown(newPost),
        summary: `${author}ã«ã‚ˆã‚‹${postTypeTemplates[postType].title}`
      },
      tags: newPost.tags,
      category: EntryCategory.LORE,
      metadata: {
        readCount: 0,
        importance: newPost.metadata.importance,
        spoilerLevel: newPost.metadata.spoilerLevel,
        firstMentionScene: currentScene?.id,
        lastUpdateScene: currentScene?.id,
        immersivePost: newPost
      },
      relations: [],
      autoGenerated: false
    }

    // WikiStoreã«ä¿å­˜
    const { addEntry } = useWikiStore.getState()
    addEntry(wikiEntry)
    
    // ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
    resetForm()
    onClose()
  }

  const formatPostAsMarkdown = (post: ImmersivePost): string => {
    const template = postTypeTemplates[post.type]
    return `# ${template.icon} ${post.title}

**æŠ•ç¨¿è€…**: ${post.author} (${getAuthorTypeLabel(post.authorType)})
**æŠ•ç¨¿æ—¥æ™‚**: ${new Date(post.timestamp).toLocaleString('ja-JP')}
**ä¿¡æ†‘æ€§**: ${post.metadata.reliability}%
**é‡è¦åº¦**: ${post.metadata.importance}/100
**å¯¾è±¡èª­è€…**: ${post.metadata.targetAudience.join(', ')}

---

${post.content}

---

*ã“ã®æŠ•ç¨¿ã¯${template.title}ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã¾ã™ã€‚*
${post.metadata.spoilerLevel > 0 ? `\nâš ï¸ **ãƒã‚¿ãƒãƒ¬ãƒ¬ãƒ™ãƒ«**: ${post.metadata.spoilerLevel}/5` : ''}
`
  }

  const getAuthorTypeLabel = (type: string): string => {
    switch (type) {
      case 'character': return 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼'
      case 'organization': return 'çµ„ç¹”'
      case 'anonymous': return 'åŒ¿å'
      default: return 'ä¸æ˜'
    }
  }

  const resetForm = () => {
    setTitle('')
    setContent('')
    setAuthor('')
    setTags([])
    setReliability(80)
    setImportance(50)
    setSpoilerLevel(0)
    setTargetAudience(['public'])
  }

  const addTag = (tag: string) => {
    if (tag && !tags.includes(tag)) {
      setTags([...tags, tag])
    }
  }

  const removeTag = (tagToRemove: string) => {
    setTags(tags.filter(tag => tag !== tagToRemove))
  }

  if (!isOpen) return null

  const currentTemplate = postTypeTemplates[postType]

  return (
    <div className="immersive-posting-overlay">
      <div className="immersive-posting-modal">
        <div className="immersive-posting-header">
          <h2>ğŸ“ æ²¡å…¥æ„ŸæŠ•ç¨¿ã‚·ã‚¹ãƒ†ãƒ </h2>
          <button className="close-btn" onClick={onClose}>Ã—</button>
        </div>

        <div className="immersive-posting-content">
          {/* æŠ•ç¨¿ã‚¿ã‚¤ãƒ—é¸æŠ */}
          <div className="post-type-selector">
            <h3>æŠ•ç¨¿ã‚¿ã‚¤ãƒ—</h3>
            <div className="post-type-grid">
              {Object.entries(postTypeTemplates).map(([type, template]) => (
                <button
                  key={type}
                  className={`post-type-btn ${postType === type ? 'active' : ''}`}
                  onClick={() => setPostType(type as ImmersivePost['type'])}
                >
                  <span className="post-type-icon">{template.icon}</span>
                  <span className="post-type-title">{template.title}</span>
                </button>
              ))}
            </div>
          </div>

          {/* åŸºæœ¬æƒ…å ± */}
          <div className="post-basic-info">
            <div className="form-row">
              <div className="form-group">
                <label>ã‚¿ã‚¤ãƒˆãƒ«</label>
                <input
                  type="text"
                  value={title}
                  onChange={(e) => setTitle(e.target.value)}
                  placeholder={`${currentTemplate.title}ã®ã‚¿ã‚¤ãƒˆãƒ«`}
                />
              </div>
            </div>

            <div className="form-row">
              <div className="form-group">
                <label>æŠ•ç¨¿è€…ã‚¿ã‚¤ãƒ—</label>
                <select value={authorType} onChange={(e) => setAuthorType(e.target.value as any)}>
                  <option value="character">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</option>
                  <option value="organization">çµ„ç¹”</option>
                  <option value="anonymous">åŒ¿å</option>
                </select>
              </div>
              
              <div className="form-group">
                <label>æŠ•ç¨¿è€…</label>
                {authorType === 'character' ? (
                  <select value={author} onChange={(e) => setAuthor(e.target.value)}>
                    <option value="">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸æŠ</option>
                    {characterEntries.map(entry => (
                      <option key={entry.id} value={entry.title}>{entry.title}</option>
                    ))}
                  </select>
                ) : authorType === 'organization' ? (
                  <select value={author} onChange={(e) => setAuthor(e.target.value)}>
                    <option value="">çµ„ç¹”ã‚’é¸æŠ</option>
                    {organizationEntries.map(entry => (
                      <option key={entry.id} value={entry.title}>{entry.title}</option>
                    ))}
                  </select>
                ) : (
                  <input
                    type="text"
                    value={author}
                    onChange={(e) => setAuthor(e.target.value)}
                    placeholder="åŒ¿åã®æŠ•ç¨¿è€…åï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
                  />
                )}
              </div>
            </div>
          </div>

          {/* æŠ•ç¨¿å†…å®¹ */}
          <div className="form-group">
            <label>å†…å®¹</label>
            <textarea
              value={content}
              onChange={(e) => setContent(e.target.value)}
              placeholder={currentTemplate.placeholder}
              rows={8}
            />
          </div>

          {/* ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è¨­å®š */}
          <div className="post-metadata">
            <h3>è©³ç´°è¨­å®š</h3>
            
            <div className="form-row">
              <div className="form-group">
                <label>ä¿¡æ†‘æ€§ ({reliability}%)</label>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={reliability}
                  onChange={(e) => setReliability(Number(e.target.value))}
                />
              </div>
              
              <div className="form-group">
                <label>é‡è¦åº¦ ({importance}/100)</label>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={importance}
                  onChange={(e) => setImportance(Number(e.target.value))}
                />
              </div>
              
              <div className="form-group">
                <label>ãƒã‚¿ãƒãƒ¬ãƒ¬ãƒ™ãƒ« ({spoilerLevel}/5)</label>
                <input
                  type="range"
                  min="0"
                  max="5"
                  value={spoilerLevel}
                  onChange={(e) => setSpoilerLevel(Number(e.target.value))}
                />
              </div>
            </div>

            {/* ã‚¿ã‚°ç®¡ç† */}
            <div className="form-group">
              <label>ã‚¿ã‚°</label>
              <div className="tag-input-container">
                <input
                  type="text"
                  placeholder="ã‚¿ã‚°ã‚’å…¥åŠ›ã—ã¦Enter"
                  onKeyPress={(e) => {
                    if (e.key === 'Enter') {
                      addTag(e.currentTarget.value)
                      e.currentTarget.value = ''
                    }
                  }}
                />
                <div className="tags-display">
                  {tags.map(tag => (
                    <span key={tag} className="tag">
                      {tag}
                      <button onClick={() => removeTag(tag)}>Ã—</button>
                    </span>
                  ))}
                </div>
              </div>
            </div>
          </div>

          {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ */}
          <div className="form-actions">
            <button className="btn-secondary" onClick={onClose}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </button>
            <button 
              className="btn-primary" 
              onClick={handleSubmit}
              disabled={!title || !content || !author}
            >
              æŠ•ç¨¿ã™ã‚‹
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}
