import { create } from 'zustand'

export enum EntryCategory {
  CHARACTER = 'character',
  LOCATION = 'location', 
  ITEM = 'item',
  EVENT = 'event',
  CONCEPT = 'concept',
  ORGANIZATION = 'organization',
  TIMELINE = 'timeline',
  LORE = 'lore',
  META = 'meta'
}

export enum RelationType {
  APPEARS_WITH = 'appears_with',
  LOCATED_IN = 'located_in',
  BELONGS_TO = 'belongs_to',
  RELATED_TO = 'related_to',
  CAUSED_BY = 'caused_by',
  PART_OF = 'part_of',
  SIMILAR_TO = 'similar_to',
  OPPOSITE_TO = 'opposite_to'
}

export enum AuthorRole {
  CHARACTER = 'character',
  NARRATOR = 'narrator',
  HISTORIAN = 'historian',
  WITNESS = 'witness',
  RUMOR_MILL = 'rumor_mill',
  SCHOLAR = 'scholar',
  JOURNALIST = 'journalist'
}

export enum PostStyle {
  FORMAL = 'formal',
  CASUAL = 'casual',
  DIARY = 'diary',
  LETTER = 'letter',
  REPORT = 'report',
  GOSSIP = 'gossip',
  POETRY = 'poetry',
  TECHNICAL = 'technical'
}

export interface AuthorPost {
  id: string
  authorId: string
  authorName: string
  authorRole: AuthorRole
  content: string
  style: PostStyle
  timestamp: Date
  mood?: string
  reliability: number
}

export interface Rumor {
  id: string
  content: string
  source?: string
  veracity: number
  spreadLevel: number
  relatedEntries: string[]
  firstHeard: Date
}

export interface InfoboxData {
  [key: string]: string | number | boolean
}

export interface MediaItem {
  id: string
  url: string
  caption?: string
  type: 'image' | 'audio' | 'video'
}

export interface Quote {
  id: string
  text: string
  speaker?: string
  context?: string
  scene?: string
}

export interface WikiContent {
  markdown: string
  summary: string
  infobox?: InfoboxData
  gallery?: MediaItem[]
  quotes?: Quote[]
  rumors?: Rumor[]
  authorVoice?: AuthorPost[]
}

export interface EntryRelation {
  targetId: string
  relationType: RelationType
  strength: number
  description?: string
  bidirectional: boolean
}

export interface EntryMetadata {
  readCount: number
  importance: number
  spoilerLevel: number
  firstMentionScene?: string
  lastUpdateScene?: string
  extractionSource: string[]
}

export interface WikiEntry {
  id: string
  title: string
  slug: string
  content: WikiContent
  tags: string[]
  category: EntryCategory
  metadata: EntryMetadata
  relations: EntryRelation[]
  autoGenerated: boolean
  createdAt: Date
  updatedAt: Date
  lastReadAt?: Date
}

interface WikiStore {
  entries: WikiEntry[]
  selectedEntryId: string | null
  selectedEntry: WikiEntry | null
  searchQuery: string
  searchTerm: string
  selectedTags: string[]
  selectedCategory: EntryCategory | 'all' | null
  showAutoGenerated: boolean
  
  // Actions
  addEntry: (entry: Omit<WikiEntry, 'id' | 'createdAt' | 'updatedAt'>) => string
  updateEntry: (id: string, updates: Partial<WikiEntry>) => void
  deleteEntry: (id: string) => void
  selectEntry: (id: string | null) => void
  setSelectedEntry: (entry: WikiEntry | null) => void
  
  // Search & Filter
  setSearchQuery: (query: string) => void
  setSearchTerm: (term: string) => void
  setSelectedTags: (tags: string[]) => void
  setSelectedCategory: (category: EntryCategory | 'all' | null) => void
  toggleShowAutoGenerated: () => void
  searchEntries: (query: string) => WikiEntry[]
  
  // Relations
  addRelation: (fromId: string, toId: string, relation: Omit<EntryRelation, 'targetId'>) => void
  removeRelation: (fromId: string, toId: string) => void
  
  // Auto-generation
  suggestEntries: (text: string, sceneId: string) => WikiEntry[]
  
  // Getters
  getFilteredEntries: () => WikiEntry[]
  getEntryById: (id: string) => WikiEntry | null
  getRelatedEntries: (id: string) => WikiEntry[]
  getRecentEntries: (limit: number) => WikiEntry[]
  getAllTags: () => string[]
  getCategoryCount: (category: EntryCategory) => number
}

export const useWikiStore = create<WikiStore>((set, get) => ({
  entries: [
    {
      id: 'entry-1',
      title: 'エリア・フォンテーヌ',
      slug: 'elia-fontaine',
      content: {
        markdown: `## 概要
王立学院の2年生。謎めいた過去を持つ少女で、古い本や魔導書に強い関心を示す。

## 外見
銀髪に青い瞳。いつも古い本を持ち歩いている。

## 性格
物静かで思慮深い。好奇心旺盛だが、自分のことはあまり語りたがらない。`,
        summary: '王立学院の謎めいた少女。古い本や魔導書に興味を持つ。',
        infobox: {
          '年齢': 17,
          '所属': '王立学院',
          '初出': '第1章',
          '髪色': '銀髪',
          '瞳色': '青'
        } as InfoboxData,
        gallery: [
          {
            id: 'img-elia-1',
            url: 'https://via.placeholder.com/300x400/87CEEB/000000?text=Elia+Portrait',
            caption: 'エリア・フォンテーヌの肖像画',
            type: 'image'
          },
          {
            id: 'img-elia-2', 
            url: 'https://via.placeholder.com/400x300/E6E6FA/000000?text=Library+Scene',
            caption: '図書館でのエリア',
            type: 'image'
          }
        ],
        quotes: [
          {
            id: 'quote-1',
            text: '真実は、いつも古い本の中に隠されているものよ',
            speaker: 'エリア・フォンテーヌ',
            context: '図書館での会話'
          }
        ],
        authorVoice: [
          {
            id: 'post-1',
            authorId: 'elia-fontaine',
            authorName: 'エリア・フォンテーヌ',
            authorRole: AuthorRole.CHARACTER,
            content: '今日も図書館で過ごした。あの本のことが気になって仕方がない。司書さんは何か知っているのかしら...',
            style: PostStyle.DIARY,
            timestamp: new Date(Date.now() - 3 * 60 * 60 * 1000),
            mood: '思案中',
            reliability: 0.9
          }
        ]
      },
      tags: ['character', 'protagonist', 'mysterious', 'academy', 'student'],
      category: EntryCategory.CHARACTER,
      metadata: {
        readCount: 23,
        importance: 80,
        spoilerLevel: 20,
        firstMentionScene: 'scene-1',
        lastUpdateScene: 'scene-1',
        extractionSource: ['scene-1']
      },
      relations: [
        {
          targetId: 'entry-2',
          relationType: RelationType.LOCATED_IN,
          strength: 0.8,
          description: '学生として在籍',
          bidirectional: false
        }
      ],
      autoGenerated: false,
      createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000),
      updatedAt: new Date(Date.now() - 3 * 60 * 60 * 1000)
    },
    {
      id: 'entry-2',
      title: '王立学院',
      slug: 'royal-academy',
      content: {
        markdown: `## 概要
この国で最も権威ある教育機関。魔法学と一般教養の両方を教える。

## 施設
- 大図書館
- 魔法実習棟
- 学生寮
- 中央広場

## 歴史
300年前に初代国王によって設立された。`,
        summary: '国内最高峰の教育機関。魔法学と一般教養を教える。',
        infobox: {
          '設立': '300年前',
          '創設者': '初代国王',
          '学生数': '約800名',
          '学科': '魔法学科、一般教養学科'
        } as InfoboxData,
        gallery: [
          {
            id: 'img-academy-1',
            url: 'https://via.placeholder.com/500x300/DDA0DD/000000?text=Royal+Academy',
            caption: '王立学院の外観',
            type: 'image'
          },
          {
            id: 'img-academy-2',
            url: 'https://via.placeholder.com/400x300/F0E68C/000000?text=Great+Library',
            caption: '大図書館の内部',
            type: 'image'
          }
        ]
      },
      tags: ['location', 'academy', 'education', 'magic'],
      category: EntryCategory.LOCATION,
      metadata: {
        readCount: 15,
        importance: 70,
        spoilerLevel: 0,
        firstMentionScene: 'scene-1',
        extractionSource: ['scene-1']
      },
      relations: [],
      autoGenerated: true,
      createdAt: new Date(Date.now() - 12 * 60 * 60 * 1000),
      updatedAt: new Date(Date.now() - 12 * 60 * 60 * 1000)
    }
  ],
  selectedEntryId: null,
  selectedEntry: null,
  searchQuery: '',
  searchTerm: '',
  selectedTags: [],
  selectedCategory: null,
  showAutoGenerated: true,

  addEntry: (entryData) => {
    const newId = `entry-${Date.now()}`
    const newEntry: WikiEntry = {
      ...entryData,
      id: newId,
      createdAt: new Date(),
      updatedAt: new Date()
    }
    
    set(state => ({
      entries: [...state.entries, newEntry]
    }))
    
    return newId
  },

  updateEntry: (id, updates) => {
    set(state => ({
      entries: state.entries.map(entry =>
        entry.id === id
          ? { ...entry, ...updates, updatedAt: new Date() }
          : entry
      )
    }))
  },

  deleteEntry: (id) => {
    set(state => ({
      entries: state.entries.filter(entry => entry.id !== id),
      selectedEntryId: state.selectedEntryId === id ? null : state.selectedEntryId
    }))
  },

  selectEntry: (id) => {
    set({ selectedEntryId: id })
    
    // 閲覧回数を増やす
    if (id) {
      const entry = get().getEntryById(id)
      if (entry) {
        get().updateEntry(id, {
          metadata: {
            ...entry.metadata,
            readCount: entry.metadata.readCount + 1
          },
          lastReadAt: new Date()
        })
      }
    }
  },

  setSearchQuery: (query) => set({ searchQuery: query }),
  setSearchTerm: (term) => set({ searchTerm: term }),
  setSelectedTags: (tags) => set({ selectedTags: tags }),
  setSelectedCategory: (category) => set({ selectedCategory: category }),
  toggleShowAutoGenerated: () => set(state => ({ showAutoGenerated: !state.showAutoGenerated })),
  
  setSelectedEntry: (entry) => set({ selectedEntry: entry, selectedEntryId: entry?.id || null }),
  
  searchEntries: (query) => {
    const state = get()
    const lowerQuery = query.toLowerCase()
    return state.entries.filter(entry =>
      entry.title.toLowerCase().includes(lowerQuery) ||
      entry.content.summary.toLowerCase().includes(lowerQuery) ||
      entry.content.markdown.toLowerCase().includes(lowerQuery) ||
      entry.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
    )
  },

  addRelation: (fromId, toId, relation) => {
    set(state => ({
      entries: state.entries.map(entry =>
        entry.id === fromId
          ? {
              ...entry,
              relations: [...entry.relations, { ...relation, targetId: toId }]
            }
          : entry
      )
    }))
  },

  removeRelation: (fromId, toId) => {
    set(state => ({
      entries: state.entries.map(entry =>
        entry.id === fromId
          ? {
              ...entry,
              relations: entry.relations.filter(rel => rel.targetId !== toId)
            }
          : entry
      )
    }))
  },

  suggestEntries: (text, sceneId) => {
    // 簡易的な自動抽出（将来的にはNLP使用）
    const suggestions: WikiEntry[] = []
    
    // 固有名詞っぽいパターンを抽出
    const properNouns = text.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g) || []
    const japaneseNames = text.match(/[一-龯]{2,4}(?:[・][一-龯]{2,4})*/g) || []
    
    const candidates = [...properNouns, ...japaneseNames]
    
    candidates.forEach(candidate => {
      if (candidate.length > 1 && !get().entries.some(e => e.title === candidate)) {
        suggestions.push({
          id: `suggestion-${Date.now()}-${Math.random()}`,
          title: candidate,
          slug: candidate.toLowerCase().replace(/\s+/g, '-'),
          content: {
            markdown: `## 概要\n${candidate}について。\n\n*この項目は自動生成されました。詳細を追加してください。*`,
            summary: `${candidate}に関する項目`
          },
          tags: ['auto-generated'],
          category: EntryCategory.CONCEPT,
          metadata: {
            readCount: 0,
            importance: 30,
            spoilerLevel: 0,
            firstMentionScene: sceneId,
            extractionSource: [text.substring(0, 100)]
          },
          relations: [],
          autoGenerated: true,
          createdAt: new Date(),
          updatedAt: new Date()
        })
      }
    })
    
    return suggestions
  },

  getFilteredEntries: () => {
    const state = get()
    let filtered = state.entries

    if (!state.showAutoGenerated) {
      filtered = filtered.filter(entry => !entry.autoGenerated)
    }

    if (state.searchQuery) {
      const query = state.searchQuery.toLowerCase()
      filtered = filtered.filter(entry =>
        entry.title.toLowerCase().includes(query) ||
        entry.content.summary.toLowerCase().includes(query) ||
        entry.tags.some(tag => tag.toLowerCase().includes(query))
      )
    }

    if (state.selectedCategory) {
      filtered = filtered.filter(entry => entry.category === state.selectedCategory)
    }

    if (state.selectedTags.length > 0) {
      filtered = filtered.filter(entry =>
        state.selectedTags.every(tag => entry.tags.includes(tag))
      )
    }

    return filtered.sort((a, b) => {
      // 重要度順、次に更新日順
      if (a.metadata.importance !== b.metadata.importance) {
        return b.metadata.importance - a.metadata.importance
      }
      return b.updatedAt.getTime() - a.updatedAt.getTime()
    })
  },

  getEntryById: (id) => {
    return get().entries.find(entry => entry.id === id) || null
  },

  getRelatedEntries: (id) => {
    const entry = get().getEntryById(id)
    if (!entry) return []

    const relatedIds = entry.relations.map(rel => rel.targetId)
    return get().entries.filter(e => relatedIds.includes(e.id))
  },

  getRecentEntries: (limit) => {
    return get().entries
      .sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())
      .slice(0, limit)
  },

  getAllTags: () => {
    const allTags = get().entries.flatMap(entry => entry.tags)
    return Array.from(new Set(allTags)).sort()
  },

  getCategoryCount: (category) => {
    return get().entries.filter(entry => entry.category === category).length
  }
}))
